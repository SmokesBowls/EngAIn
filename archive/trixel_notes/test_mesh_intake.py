"""
Test mesh_intake.py - The Mesh Intake Gate

Tests the single entry point for all geometry.
Uses a fake OBJ file to avoid dependencies.
"""

import sys
import os
import tempfile
from pathlib import Path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'core'))

from mesh_intake import intake_mesh, count_vertices_faces, compute_mesh_hash
from mesh_manifest import Anchor, Region


def create_fake_obj(path: Path, vertices: int = 4, faces: int = 2):
    """
    Create a minimal fake OBJ file for testing.
    
    Creates a simple quad (4 vertices, 2 triangular faces).
    """
    with open(path, 'w') as f:
        f.write("# Fake OBJ for testing\n")
        f.write("# Generated by test_mesh_intake.py\n\n")
        
        # Write vertices
        for i in range(vertices):
            x = (i % 2) * 1.0
            y = (i // 2) * 1.0
            f.write(f"v {x} {y} 0.0\n")
        
        f.write("\n")
        
        # Write faces (triangles)
        for i in range(faces):
            v1 = (i * 2) + 1
            v2 = v1 + 1
            v3 = v1 + 2
            f.write(f"f {v1} {v2} {v3}\n")


def test_mesh_intake_gate():
    print("=== MESH INTAKE GATE TEST ===\n")
    
    with tempfile.TemporaryDirectory() as tmpdir:
        tmpdir = Path(tmpdir)
        
        # TEST 1: Parse OBJ file
        print("TEST 1: OBJ parser")
        obj_path = tmpdir / "test.obj"
        create_fake_obj(obj_path, vertices=8, faces=12)
        
        verts, faces = count_vertices_faces(obj_path)
        assert verts == 8
        assert faces == 12
        print(f"  ‚úì Parsed: {verts} verts, {faces} faces")
        
        # TEST 2: Compute hash
        print("\nTEST 2: Mesh hash")
        hash1 = compute_mesh_hash(obj_path)
        assert len(hash1) == 64  # SHA256
        print(f"  ‚úì Hash: {hash1[:16]}...")
        
        # Modify file
        with open(obj_path, 'a') as f:
            f.write("v 1.0 2.0 3.0\n")
        
        hash2 = compute_mesh_hash(obj_path)
        assert hash1 != hash2
        print(f"  ‚úì Change detected")
        
        # TEST 3: Valid intake
        print("\nTEST 3: Valid mesh intake")
        guard_obj = tmpdir / "guard.obj"
        create_fake_obj(guard_obj, vertices=100, faces=200)
        
        manifest = intake_mesh(
            guard_obj,
            zw_concept="guard",
            ap_profile="damageable_npc",
            collision_role="solid",
            lod_class="character",
            placeholder_mesh="capsule",
            source_tool="wings3d"
        )
        
        assert manifest.is_valid()
        assert manifest.zw_concept == "guard"
        assert manifest.geometry.vertex_count == 100
        assert manifest.geometry.face_count == 200
        assert manifest.mesh_hash is not None
        print(f"  ‚úì Admitted: {manifest.zw_concept}")
        print(f"  ‚úì Geometry: {manifest.geometry.vertex_count} verts")
        print(f"  ‚úì Hash: {manifest.mesh_hash[:16]}...")
        
        # TEST 4: Invalid intake (excessive vertices)
        print("\nTEST 4: Reject excessive vertices")
        huge_obj = tmpdir / "huge.obj"
        create_fake_obj(huge_obj, vertices=6000, faces=10000)
        
        try:
            manifest = intake_mesh(
                huge_obj,
                zw_concept="huge_mesh",
                ap_profile="test",
                collision_role="solid",
                lod_class="prop",
                placeholder_mesh="cube",
                source_tool="test"
            )
            assert False, "Should have rejected"
        except ValueError as e:
            assert "Vertex count too high" in str(e)
            print(f"  ‚úì Rejected: {str(e).split('Violations:')[1].strip()[:50]}...")
        
        # TEST 5: Missing file
        print("\nTEST 5: Reject missing file")
        try:
            manifest = intake_mesh(
                tmpdir / "nonexistent.obj",
                zw_concept="missing",
                ap_profile="test",
                collision_role="solid",
                lod_class="prop",
                placeholder_mesh="cube",
                source_tool="test"
            )
            assert False, "Should have raised FileNotFoundError"
        except FileNotFoundError as e:
            print(f"  ‚úì Caught: {e}")
        
        # TEST 6: Intake with anchors
        print("\nTEST 6: Intake with semantic anchors")
        merchant_obj = tmpdir / "merchant.obj"
        create_fake_obj(merchant_obj, vertices=150, faces=250)
        
        anchors = [
            Anchor(name="hand_right", position=[0.3, 1.2, 0.0], purpose="item_hold"),
            Anchor(name="head", position=[0.0, 1.8, 0.0], purpose="hat_attach")
        ]
        
        manifest = intake_mesh(
            merchant_obj,
            zw_concept="merchant",
            ap_profile="interactable",
            collision_role="solid",
            lod_class="character",
            placeholder_mesh="capsule",
            source_tool="wings3d",
            anchors=anchors
        )
        
        assert len(manifest.anchors) == 2
        assert manifest.anchors[0].name == "hand_right"
        print(f"  ‚úì Anchors: {len(manifest.anchors)}")
        
        # TEST 7: Intake with regions
        print("\nTEST 7: Intake with mesh regions")
        door_obj = tmpdir / "door.obj"
        create_fake_obj(door_obj, vertices=50, faces=80)
        
        regions = [
            Region(name="frame", material_slot=0, collision="solid"),
            Region(name="handle", material_slot=1, collision="trigger")
        ]
        
        manifest = intake_mesh(
            door_obj,
            zw_concept="door",
            ap_profile="destructible",
            collision_role="solid",
            lod_class="environment",
            placeholder_mesh="cube",
            source_tool="magicavoxel",
            regions=regions
        )
        
        assert len(manifest.regions) == 2
        assert manifest.regions[0].collision == "solid"
        print(f"  ‚úì Regions: {len(manifest.regions)}")
        
        # TEST 8: Different source tools
        print("\nTEST 8: Multiple source tools")
        tools = ["wings3d", "magicavoxel", "meshlab", "blender", "ai_generated"]
        
        for tool in tools:
            obj = tmpdir / f"{tool}_test.obj"
            create_fake_obj(obj, vertices=50, faces=80)
            
            manifest = intake_mesh(
                obj,
                zw_concept=f"{tool}_mesh",
                ap_profile="generic",
                collision_role="solid",
                lod_class="prop",
                placeholder_mesh="cube",
                source_tool=tool
            )
            
            assert manifest.geometry.source_tool == tool
        
        print(f"  ‚úì All tools admitted: {tools}")
        
        # TEST 9: Invalid collision role
        print("\nTEST 9: Reject invalid collision_role")
        bad_obj = tmpdir / "bad.obj"
        create_fake_obj(bad_obj, vertices=50, faces=80)
        
        try:
            manifest = intake_mesh(
                bad_obj,
                zw_concept="bad",
                ap_profile="test",
                collision_role="invalid_role",  # ‚Üê Invalid
                lod_class="prop",
                placeholder_mesh="cube",
                source_tool="test"
            )
            assert False, "Should have rejected"
        except ValueError as e:
            assert "collision_role" in str(e)
            print(f"  ‚úì Rejected invalid collision_role")
    
    print("\n" + "="*60)
    print("‚úÖ MESH INTAKE GATE: ALL TESTS PASS")
    print("="*60)
    print("\nProven:")
    print("  ‚úì OBJ parser (vertex/face counting)")
    print("  ‚úì Hash computation (change detection)")
    print("  ‚úì Valid meshes admitted")
    print("  ‚úì Invalid meshes rejected")
    print("  ‚úì Missing files caught")
    print("  ‚úì Anchors supported")
    print("  ‚úì Regions supported")
    print("  ‚úì Multiple source tools")
    print("  ‚úì Contract violations caught")
    print("\nüö™ The gate is the law. All geometry must pass through.")


if __name__ == "__main__":
    test_mesh_intake_gate()
