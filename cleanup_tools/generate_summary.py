#!/usr/bin/env python3
import json
import os
import subprocess
from pathlib import Path
from collections import Counter
from datetime import datetime

REPO_ROOT = Path(__file__).resolve().parents[1]  # cleanup_tools/.. = repo root
REPORT_DIR = REPO_ROOT / "cleanup_reports"

WORKS_CMD = ["pytest", "godotengain/engainos/tests"]

# Dynamically find all trace files
TRACE_FILES = list(REPORT_DIR.glob("import-trace-*.json"))

DUPES_FILE = REPORT_DIR / "duplicate-modules.txt"
UNUSED_FILE = REPORT_DIR / "unused-candidates.txt"

def run_pytest() -> int:
    REPORT_DIR.mkdir(parents=True, exist_ok=True)
    out_path = REPORT_DIR / "works-baseline.txt"
    proc = subprocess.run(
        WORKS_CMD,
        cwd=str(REPO_ROOT),
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
    )
    out_path.write_text(proc.stdout, encoding="utf-8")
    return proc.returncode

def summarize_import_trace(path: Path) -> str:
    if not path.exists():
        return f"- {path.name}: missing"
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        return f"- {path.name}: unreadable ({e})"

    # Adjusted to match the actual JSON property 'imported_files' generated by previous trace task
    mods = data.get("imported_files", []) or []
    by_class = Counter(m.get("class", "unknown") for m in mods)

    # detect any godotsim imports
    godotsim_mods = [m for m in mods if m.get("class") == "godotsim"]
    godotsim_count = len(godotsim_mods)

    ok = data.get("ok")
    return f"- {path.name}: ok={ok}, loaded_by_class={dict(by_class)}, godotsim={godotsim_count}"

def head_file(path: Path, n: int = 20) -> list[str]:
    if not path.exists():
        return []
    lines = path.read_text(encoding="utf-8", errors="replace").splitlines()
    return lines[:n]

def main():
    stamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    exit_code = run_pytest()
    baseline_passed = (exit_code == 0)

    summary_lines = []
    summary_lines.append(f"generated: {stamp}")
    summary_lines.append(f"baseline command: {' '.join(WORKS_CMD)}")
    summary_lines.append(f"baseline exit code: {exit_code}")
    summary_lines.append(f"baseline passed: {'Yes' if baseline_passed else 'No'}")
    summary_lines.append("")

    summary_lines.append("import traces:")
    # Sort traces: prioritize non-test traces
    core_traces = [tf for tf in TRACE_FILES if "test-" not in tf.name]
    test_traces = [tf for tf in TRACE_FILES if "test-" in tf.name]
    
    for tf in sorted(core_traces):
        summary_lines.append(summarize_import_trace(tf))
    
    if test_traces:
        summary_lines.append(f"- (plus {len(test_traces)} test-specific traces aggregated)")
        # Optionally, check if any of THEM imported godotsim
        godotsim_in_tests = 0
        for tf in test_traces:
            try:
                data = json.loads(tf.read_text(encoding="utf-8"))
                godotsim_in_tests += len([m for m in data.get("imported_files", []) if m.get("class") == "godotsim"])
            except:
                pass
        if godotsim_in_tests > 0:
            summary_lines.append(f"  âš  Alert: {godotsim_in_tests} godotsim imports detected across all tests.")
    summary_lines.append("")

    # Quick visibility into duplicate modules + unused candidates, if present
    if DUPES_FILE.exists():
        summary_lines.append("top duplicate module names by risk (first 15 lines):")
        for line in head_file(DUPES_FILE, 15):
            summary_lines.append(line)
        summary_lines.append("")
    else:
        summary_lines.append("duplicate-modules.txt: missing")
        summary_lines.append("")

    if UNUSED_FILE.exists():
        summary_lines.append("top unused candidates (first 25 lines):")
        for line in head_file(UNUSED_FILE, 25):
            summary_lines.append(line)
        summary_lines.append("")
    else:
        summary_lines.append("unused-candidates.txt: missing")
        summary_lines.append("")

    # Governance statement
    if baseline_passed:
        summary_lines.append("governance: cleanup actions allowed (baseline green).")
    else:
        summary_lines.append("governance: cleanup actions blocked (baseline not green).")

    (REPORT_DIR / "summary.txt").write_text("\n".join(summary_lines) + "\n", encoding="utf-8")
    print("Wrote:", REPORT_DIR / "works-baseline.txt")
    print("Wrote:", REPORT_DIR / "summary.txt")
    print("Baseline passed:", baseline_passed)

if __name__ == "__main__":
    main()
