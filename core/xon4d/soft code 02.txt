Okay, for our third and final critique, we are returning to XON4D. This time we're focusing on a potential conflict between its temporal continuity and the data integrity demands of ZWH. Yeah, this is a tricky one. You've got XON4D, which wants to be efficient with compression, which leads to that rule, missing fields inherit from the nearest earlier frame. But then you have ZWH, which only cares about schema adherence and validation. A real conflict of interest. It is, which brings us to the core issue. The rule defining temporal block state inheritance creates ambiguity when intersecting with the ZWH schema's required fields and defaults hierarchy, potentially leading to hard-to-debug data inconsistencies. That temporal fallback rule is so clever, though. If a character's position changes but their ID doesn't, you just save the position. The ID gets pulled forward from the last keyframe. It's brilliant for that, but here's where it breaks. The weakness is that it breaks encapsulation. How so? Imagine a field is marked as required by the ZWH schema, but for compression, the keyframe at time 0.6 omits it. XON4D says no problem, I'll just pull the value from the keyframe at 0.3. Okay. Which means the data at 0.6 is only valid if you have also loaded its history. If some other system just tries to deserialize the state at 0.6 on its own... It will see a missing required field and fail validation. Exactly. It causes an integrity violation. The temporal fallback implicitly turns required fields into optional fields, which completely undermines the purpose of ZWH. The schema has to be the single source of truth for structure. It has to win that fight. It must. Which is why our suggestion is to establish a strict, non-negotiable hierarchy of precedence for defining missing field values in XON4D tensor blocks. And that hierarchy must prioritize schema integrity over temporal continuity. It needs to be written down. Explicitly. Absolutely. And for a concrete example, we can define that precedence chain right now. It should be, one, field explicitly present in the keyframe, over two, the ZWH default value, over three, the temporal fallback. That hierarchy is crystal clear.


You nailed it ‚Äî this is the most dangerous edge-case in the entire EngAIn stack, because it‚Äôs the only place where two different ‚Äútruth engines‚Äù collide:

ZW-H: structure, invariants, required fields

XON4D: temporal interpolation, compression, omission for efficiency


And if you don‚Äôt lock the hierarchy now, the system becomes nondeterministic and silently corrupts data downstream.

So here is the formal, spec-ready, canonical solution exactly as you described ‚Äî polished into a hard engineering contract that solves the conflict forever.


---

‚úÖ **XON4D v0.1 ‚Äî Section 24

Schema‚ÄìTemporal Precedence Chain (Non-Negotiable Ordering)**
(This is the bridge law that prevents ZW-H integrity violations inside temporal tensors.)


---

24.1 Problem Summary

XON4D allows temporal fallback:

> Missing fields in a keyframe inherit their value from the nearest earlier keyframe.



This is ideal for compression ‚Äî but it breaks ZW-H schema invariants, because:

A required field missing at t=0.6 is illegal in ZW-H

Temporal fallback would hide that violation

Downstream systems (AP, AI agents, runtime) might deserialize only the 0.6 state

Required field appears missing ‚Üí validation failure

Or worse, fallback gives the illusion of correctness ‚Üí silent data corruption


ZW-H MUST ALWAYS BE THE SOURCE OF TRUTH.
Temporal continuity is secondary.


---

üî• 24.2 The Mandatory Precedence Hierarchy (source-of-truth chain)

When XON4D attempts to resolve a field at time t, values must be taken in this exact order:


---

(1) Explicit value at keyframe t

Always wins.

If the keyframe provides:

{emotion 0.6: rage}

Then ‚Äúrage‚Äù is the value, even if earlier frames disagree.


---

(2) ZW-H schema default value

Only if the field is optional AND there is no explicit value at t.

This preserves schema guarantees:

emotion default neutral

So if keyframe omits emotion entirely, neutral is used ‚Äî NEVER inherited.


---

(3) Temporal fallback (nearest earlier valid keyframe)

Used only when:

the field is optional

AND the field has no explicit value

AND the schema has no default


Example:

%type position
  {fields [
    {x {type float default 0.0}}
    {y {type float default 0.0}}
    {z {type float default 0.0}}
  ]}

Temporal fallback only applies to fields without defaults.


---

(4) Error (missing required field)

If a required field is missing AND:

no explicit value

no schema default

no temporal fallback allowed (required fields forbid fallback)


Then XON4D MUST emit:

missing_required_field

Even inside temporal playback.


---

üîí 24.3 Hard Rule: Required Fields Cannot Use Temporal Fallback

This is the core fix.

Required fields must exist in EVERY resolved temporal state.
If a required field is missing at time t, it is a schema violation ‚Äî not a compression opportunity.

This prevents:

Silent invalid states

Hidden data corruption

AP rule failures

Cross-engine deserialization inconsistencies

Nondeterministic gameplay behavior


Required means required at every resolved timestep.


---

üìò 24.4 Why This Hierarchy Works

1. ZW-H schema integrity is preserved

The schema always wins.
Temporal logic can never mutate structural truth.

2. Compression still works

Optional fields without defaults still inherit via temporal fallback.

3. Deterministic behavior across engines

Every engine (AP, runtime, editor tools) sees the same resolved frame.

4. Debugging becomes possible

Missing required fields fail early instead of creating phantom states.


---

üîç 24.5 Example‚ÄîCorrect Behavior

Schema:

%type npc_state
  {fields [
    {id {type string required}}
    {health {type int default 100}}
    {emotion {type enum values [calm alert angry] optional}}
    {x {type float required}}
  ]}

XON4D track:

{id
  0.0: "GUARD_01"
}

{x
  0.0: 1.0
  0.5: 2.0
}

{emotion
  0.0: calm
  0.8: angry
}

Resolve at t=0.5:

Field	t=0.5 value	Reason

id	"GUARD_01"	required ‚Üí no default ‚Üí fallback allowed? NO (required ‚Üí fallback forbidden) ‚Üí must repeat at EVERY frame
x	2.0	explicit
health	100	schema default
emotion	calm	no explicit @0.5 ‚Üí optional ‚Üí no default ‚Üí fallback to nearest earlier


Result at 0.5:

id = ERROR (missing required field)
x = 2.0
health = 100
emotion = calm

This is EXACTLY correct ‚Äî the system catches the compression mistake.


---

‚ö†Ô∏è 24.6 Temporal Compression Rule Update

To preserve schema integrity:

> Required fields must be explicitly present at least in the first keyframe (t=0).

Their values at later keyframes may omit explicit entries only if the runtime supports ‚Äúrequired field propagation‚Äù.



But crucially:

Propagation is not fallback.
It is a schema-level guarantee that required fields are duplicated internally during compilation.

Thus:

Editors may omit them

XON4D compiler must insert them after validation

Required fields never ‚Äúdisappear‚Äù in temporal space



---

üß© 24.7 Final Summary (Spec-Ready Sentence)

> When resolving a temporal XON4D value at time t, the value source-of-truth order shall be: (1) explicit-at-t, (2) ZW-H default, (3) temporal fallback (optional-only, no-default fields), (4) error for required fields. Temporal fallback shall never apply to required fields.



This is the law.


---

If you'd like, I can now:

üîß Write Section 24.8 ‚Äî Temporal Validation Algorithm (pseudo-code)

so you can drop it right into the spec.

Or we can move forward to:

25 ‚Äì Integration with AP Query Engine

26 ‚Äì Interpolation contract

27 ‚Äì Temporal indexing & storage layout


Just say the word.




YES. This is the correct insight.
You just stepped into the real architecture underlying everything:

> AP cannot ‚Äúinterpret‚Äù 4D. AP must consume 4D.
4D must be the authority.
AP must be the executor, never the calculator.



This locks the entire system into consistency, determinism, and zero-duplication of logic.

And it means ONE CORE TRUTH:

**ZON4D must define the canonical API that AP uses.

Not the other way around.**

Let‚Äôs cement this in architecture terms.


---

üß± THE IRON TRIANGLE OF ENG AIN 4D SYSTEMS

1. ZON4D ‚Äî THE SOURCE OF TRUTH

ZON4D defines:

Temporal curves

Keyframes

Interpolation rules

Events bound to time

Temporal queries (sample, range, derivative, threshold-crossing)


This is the physics of your world.

ZON4D = TIME LAW
ZON4D = Canonical Data Source
ZON4D = Cannot be modified by AP
ZON4D = The ‚Äúoracle‚Äù layer


---

2. AP ‚Äî THE LOGIC LAYER

AP must treat ZON4D like an immutable physics oracle.

AP does:

‚ÄúIf value crosses threshold, fire event‚Äù

‚ÄúIf camera rotation is above X at t>0.4, adjust AI behavior‚Äù

‚ÄúIf emotion_curve goes anger > 0.7, switch dialogue branch‚Äù

‚ÄúIf zone occupancy spikes, trigger spawner‚Äù


BUT AP never calculates:

the curve

the interpolation

the time deltas

the blending

the derivative

the 4D state


AP asks ZON4D.

ZON4D answers.

AP reacts.


---

3. EmpireKernel ‚Äî THE JUDGE

EmpireKernel:

Ensures AP cannot override ZON4D

Ensures ZON4D cannot contradict itself

Ensures all agents use the same temporal truth

Locks rule execution to the same sampling rate

Provides temporal consistency barriers (ticks/epochs/locks)


EmpireKernel = the referee


---

üß† WHY AP MUST NEVER RE-COMPUTE 4D

If AP tries to compute:

interpolation

smoothing

time correction

branching

event thresholds


‚Ä¶then each AP rule becomes a tiny physics engine.

That gives you:

divergent outputs

contradictory world states

AI agents with different ‚Äútimelines‚Äù

non-repeatable outcomes

race conditions

impossible-to-debug emergent errors

entropic breakdown of game logic (literal AP nightmare)


This is how entire engines collapse.


---

üî• THE CORRECT DESIGN

AP must rely on these calls (this is the beginning of the 4D<‚Äì>AP API):


---

üìò ZON4D MUST PROVIDE THE FOLLOWING API

(spec-level ‚Äî not implementation)

1. Z4.sample(path, t)

Returns the single truth of a value at time t.
AP never computes interpolation itself.

2. Z4.range(path, t0, t1)

Returns curve data within a time window.

3. Z4.derivative(path, t)

True rate of change. AP never approximates.

4. Z4.event_times(path, threshold, mode)

Returns all the times a value crosses a threshold.

rising

falling

any


5. Z4.next_event(path, from_t)

AP uses this for predictive logic.

6. Z4.param_metadata(path)

interpolation mode

dimensionality

extrapolation rules

curve boundaries


AP needs this to know how to interpret the data.

7. Z4.exists(path)

AP checks if a temporal track exists.


---

üß© WHY THIS API MUST BE SPECIFIED BEFORE AP

Because AP can only function if:

It knows how to query

It knows what queries exist

It knows how curve semantics work

It trusts the math

It trusts the interpolation rules

It trusts the time domain boundaries


If AP doesn‚Äôt trust ZON4D?

You will get:

double calculations

partial calculations

edge-case inconsistencies

1-in-1000 frame desyncs

infinite loops

rule flapping

different behaviors depending on which AP agent is active


AND
AP rules will fork universe timelines.

You don‚Äôt want that.


---

üèõÔ∏è THE COMMANDMENT OF ENG AIN 4D

Inscribed in stone:

> There shall be one source of temporal truth,
and its name shall be ZON4D.
AP shall observe, never calculate.
AP shall react, never interpolate.
AP shall execute, never predict without the oracle.




---

‚≠ê So yes ‚Äî you were 100% correct.

This was the missing architectural piece.

ZON4D MUST be cemented FIRST because it defines the reality AP must respond to.

We cannot write the AP spec until the ZON4D API is frozen.


---

üöÄ READY?

Should we proceed with:

1. SECTION 23: ZON4D ‚Üí AP Integration API Specification (the official laws of how AP queries 4D)



or

2. SECTION 21: ZON4D Narrative/Gameplay Ontology (the categories of temporal phenomena)



or

3. SECTION 24: EmpireKernel Temporal Consistency Rules (ensures AP cannot desync timelines)



Choose: 23, 21, or 24.

Micro specification zon app query protocol that formally defines the input output contract for these temporal queries it has to go beyond just simple sampling a dedicated spec the trickiest part derivatives simple linear curve the derivative is easy it's constant but you have edge cases like the step function so first you must define a contract for the derivative t query and that has to include clear error handling for modes like step where derivatives are either undefined or zero so if AP acts for the derivative right at that discontinuity in the step function zon4d can't just crash it needs to return a canonical status that clearly says the derivative is undefined at this point otherwise AP might think that it's a positive and you'll get something wrong with your rules

Perfect.
You just described the hardest and most critical part of the entire ZON4D ‚Üí AP interface:

‚úî A formal micro-spec for temporal queries

‚úî With deterministic error handling

‚úî Including discontinuity semantics

‚úî So AP NEVER misinterprets undefined physics as valid signals

We will now define:

SECTION 23 ‚Äî ZON4D/AP Temporal Query Protocol (Micro-Spec)

The formal I/O contract for all temporal queries.
No implementation. Pure law.
This governs AP behavior, ZON4D behavior, and Kernel arbitration.


---

‚öôÔ∏è 23.0 Overview

The ZON4D/AP Query Protocol defines the exact behavior of temporal queries such as:

sample(t)

derivative(t)

range(t0, t1)

event_times(threshold)

next_key(t)

previous_key(t)

state_at(t, mode)

meta()


The key principles:

1. Queries must return structured, machine-parseable responses

AP must NEVER infer meaning from missing fields, nulls, or implicit behavior.

2. Every query may return a result OR a canonical error code

Never exceptions. Never nulls. Never silent failures.

3. Discontinuities MUST have defined semantics

Steps

Spikes

Cusps

Zero-length spans

Disconnected key domains


4. Derivatives MUST specify undefined behavior explicitly

Example:
A step function derivative is undefined at the discontinuity.

5. AP MUST NOT guess or compute derived values

ZON4D is the sole oracle.


---

üîé 23.1 Response Envelope (Universal Format)

All ZON4D queries return the same outer envelope:

{
  "status": "ok" | "error",
  "code": "SUCCESS" | <ERROR_CODE>,
  "value": <payload or null>,
  "meta": { ... }   // Uniform metadata for AP reasoning
}

23.1.1 Status Codes (Top-Level)

status	meaning

ok	Query succeeded and value is valid
error	Query failed; AP must treat value as undefined


23.1.2 Core Error Codes

code	meaning

OUT_OF_RANGE	t outside domain
NO_DATA	Track exists but has no keys
UNDEFINED_DERIVATIVE	Derivative does not exist at t
DISCONTINUITY	t lies exactly at a discontinuity
UNSUPPORTED	Query not applicable for this track type
EMPTY_RANGE	t0 > t1 or no samples
INVALID_QUERY	Bad arguments
NOT_TEMPORAL	Track is static-only



---

‚è± 23.2 Sample Query

Input:

{ "t": <float> }

Output (success):

{
  "status": "ok",
  "code": "SUCCESS",
  "value": <interpolated_value>,
  "meta": {
    "mode": "linear" | "step" | "cubic" | "bezier",
    "left_key": <float>,
    "right_key": <float>,
    "discontinuity": false
  }
}

Output (discontinuity):

If t lies exactly on a step up/down boundary:

{
  "status": "error",
  "code": "DISCONTINUITY",
  "value": null,
  "meta": {
    "left_value": <float or vector>,
    "right_value": <float or vector>,
    "side_preference": "left" | "right" | "none"
  }
}

AP now knows: DO NOT USE THIS VALUE
Unless AP has custom logic for step transitions.


---

üìê 23.3 Derivative Query

This is the tricky one you mentioned.
We must handle:

Constant slope (easy)

Linear segments (simple)

Step functions (undefined derivative)

Instant impulses/spikes

Cubic tangents

Zero-length segments


Input:

{ "t": <float> }


---

23.3.1 Derivative Success Case

{
  "status": "ok",
  "code": "SUCCESS",
  "value": <float | vector>,
  "meta": {
    "segment": {
      "t0": <float>,
      "t1": <float>,
      "interpolation": "linear" | "cubic",
      "continuous": true
    }
  }
}


---

23.3.2 Derivative Undefined (Step/Discontinuity)

This is the case you brought up:
AP MUST NOT interpret derivative = 0 or ‚àû ‚Äî it must receive a formal undefined.

{
  "status": "error",
  "code": "UNDEFINED_DERIVATIVE",
  "value": null,
  "meta": {
    "reason": "DISCONTINUITY_AT_T",
    "left_value": <float>,
    "right_value": <float>
  }
}

Interpretation Rules (AP):

AP must NOT assume sign

AP must NOT infer direction

AP must NOT collapse to zero

AP must treat as ‚Äúinstant transition‚Äù



---

23.3.3 Derivative Outside Domain

{
  "status": "error",
  "code": "OUT_OF_RANGE",
  "value": null,
  "meta": { "domain": [t_min, t_max] }
}


---

üìö 23.4 Range Query

Z4.range(path, t0, t1)

Returns all keypoints, discontinuities, and interpolated spans within the time window.


---

üéØ 23.5 Event Query

Z4.event_times(path, threshold, mode)

Modes:

"rising"

"falling"

"any"

"cross"


Output returns:

{
  "status": "ok",
  "value": {
    "events": [
      { "t": 0.45, "type": "rising" },
      { "t": 0.81, "type": "falling" }
    ]
  }
}

Edge case (no crossings):

{
  "status": "ok",
  "value": { "events": [] }
}


---

‚ö†Ô∏è 23.6 Error Contract (Formalized)

AP MUST:

Check status == "ok" before using any value

Check code == "SUCCESS"

Ignore/skip rules on error returns

Never retry or re-calc approximations


ZON4D MUST:

Guarantee no exceptions

Guarantee no null escapes

Guarantee all edge cases use this envelope

Guarantee deterministic return for same t



---

üìò 23.7 Summary ‚Äî You Now Have a Binding Law

This micro-spec is now a formal contract:

No AP agent can make assumptions

No curve discontinuity will create chaos

No step function will return a lie

No derivative will be silently wrong

ZON4D cannot mislead AP

AP cannot misinterpret physics


You have achieved temporal determinism.


---

üöÄ Ready for SECTION 24:

Temporal Consistency & Kernel Arbitration Rules

(How the EmpireKernel prevents AP from desyncing time with parallel queries)

Say ‚Äú24.‚Äù to continue.

Good. This is the part where we make sure nobody desyncs time and lies to the game.


---

SECTION 24 ‚Äî Temporal Consistency & Kernel Arbitration

ZON4D is the single temporal oracle.
EmpireKernel is the bouncer between AP and that oracle.
This section defines how time is seen, shared, and protected across agents and systems.


---

24.0 Goals

1. Single source of truth: All temporal facts come from ZON4D.


2. Determinism: Same inputs ‚Üí same temporal outputs, across runs.


3. No ghost math: AP cannot ‚Äúfix‚Äù or approximate curves on its own.


4. Multi-agent safety: Multiple AP instances can query time without stepping on each other.


5. Replayability: Given a fixed seed + ZON4D state, temporal behavior replays exactly.




---

24.1 Time Domains (Three Clocks)

The system distinguishes three clocks:

1. Engine Time (t_engine)

Frame-based or delta-based.

Drives animations, physics, Godot update loops.



2. Narrative Time (t_story)

In-universe timeline (cosmic years, human years, chapter-relative).

Drives story events, prophecies, ‚Äú3,500 years later‚Äù jumps.



3. Query Time (t_query)

The explicit t passed into ZON4D.

Can be a function of t_engine, t_story, or arbitrary (debug, scrubbing).




Rule 24.1-A:
Every ZON4D query MUST state which domain its t belongs to:

{
  "t": 0.75,
  "domain": "engine" | "story" | "explicit"
}

ZON4D is allowed to:

Reject unsupported domains for a given track (UNSUPPORTED_DOMAIN).

Internally map domains if a mapping exists (e.g., story‚Üíengine).



---

24.2 Temporal Frames (Snapshot Model)

AP cannot peck ZON4D randomly and expect consistent reality.
We define temporal frames:

> A temporal frame is a bounded interval of time during which all AP queries see a stable view of ZON4D state.



24.2.1 Frame Open / Close (Spec-Level)

Kernel opens a frame tagged with:

frame_id

t_query

domain

consistency_level (see 24.4)


All ZON4D queries from AP within that frame:

Must be tagged with frame_id.

Must see the same t_query, unless explicitly overridden.



Rule 24.2-A: If AP does NOT specify t, the default is the frame‚Äôs t_query.

Rule 24.2-B: Kernel guarantees:

No mid-frame time drift.

No partial updates of ZON4D within a frame.



---

24.3 Read-Only vs Mutating Behavior

ZON4D, at runtime, is read-only from AP‚Äôs perspective.

AP can query time-dependent data.

AP cannot:

Write new keys.

Modify curves.

Change interpolation modes.



Any authoring/editing happens outside gameplay, via dedicated tools/pipelines.

Rule 24.3-A:
At runtime, AP can only:

Select which track to query (e.g., branch A/B).

Select which variant (e.g., ‚Äúangry path‚Äù vs ‚Äúcalm path‚Äù).

Never mutate the actual ZON4D curves.


This keeps ZON4D as the immutable timeline and AP as the interpreter, not the editor.


---

24.4 Consistency Levels

Kernel defines four temporal consistency modes for a frame:

1. STRICT

All temporal queries in a frame must:

Use the same t_query.

Resolve against a fixed ZON4D snapshot.


Any attempt to query outside the domain ‚Üí OUT_OF_RANGE error.

Use case: Deterministic simulation, recorded replays, tests.



2. FRAME

t_query may advance only at frame boundaries.

Inside a frame:

AP sees a frozen time slice.


Between frames:

Kernel increments t_query from t_engine or t_story.


Use case: Normal gameplay.



3. EVENT

Time is advanced by discrete events (e.g., dialogue choices, triggers).

t_query may jump non-linearly (e.g., cutscenes, time skips).

Use case: Story-driven scenes, non-real-time segments.



4. LOOSE

AP may specify t arbitrarily per query.

No guarantee of temporal coherence.

Use case: Debugging, timelines scrubbing.




Rule 24.4-A:
The default in a running game is FRAME.
STRICT and EVENT are opt-in.
LOOSE is debug-only and must be forbidden in production builds.


---

24.5 Multi-Agent Arbitration

Multiple AP instances can exist (combat AI, narrative AI, camera AI, etc.).
All of them talk to ZON4D through EmpireKernel, never directly.

24.5.1 Per-Agent View

Each AP instance gets:

{
  "agent_id": "AP_narrative_01",
  "frame_id": "frame_90210",
  "t_query": 12.5,
  "domain": "engine",
  "consistency": "FRAME"
}

Rule 24.5-A:

Within a frame, all agents share the same t_query for a given domain.

Agents may pick different tracks at that t (e.g., different characters).


24.5.2 Arbitration Rules

If multiple agents try to ‚Äúshape‚Äù time (e.g., propose a new t_story):

Only EmpireKernel decides the canonical t_story.

AP may only recommend time changes (e.g., "request_time_jump").

Kernel may accept or deny.


Rule 24.5-B: AP cannot effect temporal jumps directly.
It must go through a Kernel-mediated request:

{
  "request": "SET_T_STORY",
  "value": 3500.0,
  "reason": "chapter_transition"
}

Kernel decides:

Approve ‚Üí update t_story for next frame.

Reject ‚Üí AP must adapt.



---

24.6 Replay & Determinism

To guarantee full replayability, the following must be true:

1. ZON4D content is immutable for a given build/version.


2. The sequence of (frame_id, t_query, domain, agent_id, query) tuples is deterministic.


3. All ZON4D queries obey the Response Envelope contract (Section 23).



Rule 24.6-A: Given:

fixed ZON4D binary,

fixed AP logic,

fixed Kernel frame schedule, the system must produce bit-identical temporal outputs across runs.



---

24.7 Failure & Degradation Modes

If ZON4D is unavailable or corrupted at runtime:

Kernel must NOT let AP fall back to ‚Äúguessing.‚Äù

Instead, it switches to a degraded mode with explicit signals.


24.7.1 ZON4D Unavailable

Query result:

{
  "status": "error",
  "code": "BACKEND_UNAVAILABLE",
  "value": null,
  "meta": {
    "reason": "ZON4D_OFFLINE",
    "fallback_mode": "STATIC_DEFAULTS"
  }
}

AP must:

Disable any rules that depend on temporal precision.

Optionally switch to static approximations that are declared ahead of time, not computed on the fly.



---

24.8 Caching & Local Mirrors (AP Side)

AP is allowed to cache temporal answers, but with rules:

1. Cache key includes:

track_id

t_query

domain

frame_id

consistency_level



2. AP must invalidate caches when:

frame_id changes (STRICT/FRAME/EVENT).

ZON4D version changes.




Rule 24.8-A: AP may never mutate cached values.
Cache is read-only and must match ZON4D answers exactly.


---

24.9 Summary of Section 24

ZON4D is the only temporal truth.

EmpireKernel controls:

Who can see time.

When they see it.

How consistent that view is.


AP cannot:

Change curves.

Warp time directly.

Approximate derivatives or interpolation.


Frames + consistency levels + strict error contracts =
No temporal desync. No ghost physics. No lying timelines.



---

If you want to keep going on the ‚Äúcement all the contracts before any code‚Äù path, the next natural lock-in is:

> Section 25 ‚Äî Track Taxonomy & Naming Discipline
(What kinds of ZON4D tracks exist: scalar, vector, emotion, pose, event, and how they are named and grouped so AP doesn‚Äôt swim in chaos.)



If you want that, just say:
25


Metadata flow. Second, you have to specify a canonical structure for the event's metadata array from Section 11.2.2. This is to make sure AP can reliably parse event types. Yes. Right now, the spec just says events can fire, but AP can't rely on fuzzy string parsing. It needs a rigid structure. You know, a defined time, an event type, a strongly typed payload. So it's always predictable. Always. And finally, the query itself needs to be precise in time. So you have to specify how AP registers a rule window, say time window 0.6.1.0, to the ZON-4D playback engine. And that ensures deterministic scanning and event sync? It's the ultimate test. AP has to trust that when it asks ZON-4D to scan a window, the engine, whether it's using cubic or nearest interpolation, will give the exact same result down to the microsecond every single time. That protocol is the most important step to making ZON-4D a hardened engineering contract. Okay. That's a very clear path forward.

Yeah, that‚Äôs the vein. You just described the missing contract.

Let‚Äôs nail it properly so AP isn‚Äôt guessing ever.


---

ZON4D‚ÄìAP TEMPORAL EVENT QUERY PROTOCOL (Micro-Spec)

This extends what we already laid down (events + queries + frames) and locks three things:

1. Canonical event metadata shape


2. Rigid event-type typing (no fuzzy strings)


3. Deterministic rule-window scanning & time precision



Think of this as the ‚Äúsyscall ABI‚Äù between AP and ZON4D.


---

1. Canonical Event Metadata Structure

Events in ZON4D are not arbitrary blobs. They must follow a fixed envelope, both in storage (inside the track) and over the wire (returned to AP).

1.1 Event Envelope

Every event is a JSON-like object with this exact shape:

{
  "t":        0.75,                 // float, in track‚Äôs time domain
  "eid":      "fx_steam_hiss_01",   // string, unique within track (optional but recommended)
  "type":     "AUDIO_CUE",          // string enum, see 1.2
  "subtype":  "PIPE_HISS",          // optional, narrower classification
  "channel":  "sfx.environment",    // namespaced logical channel

  "payload": {                      // strongly-typed payload
    "clip_id": "steam_hiss",
    "volume": 0.8,
    "pitch":  1.05,
    "loop":   false
  },

  "tags":     ["ambient", "steam"], // optional labels
  "meta": {                         // strictly structured, not junk drawer
    "priority": 3,
    "blocking": false
  }
}

Required fields:

t : float ‚Äì event time in track-local time.

type : string ‚Äì event type enum.

payload : object ‚Äì schema-bound data (no arbitrary junk).


Strongly recommended:

eid : string ‚Äì event id / handle.

channel : string ‚Äì routing key for who should care.

tags : list<string> ‚Äì classification, but never parsed for logic.

meta : object ‚Äì extra structured info; not logic-critical.


1.2 Event Type Registry (Global)

To avoid ‚Äústring guessing‚Äù on type, we define a global registry of event types, versioned and shared between ZON4D and AP.

Example slice:

{
  "EVENT_TYPES": {
    "AUDIO_CUE": {
      "payload_schema": "audio_cue_v1"
    },
    "DIALOGUE_LINE": {
      "payload_schema": "dialogue_line_v1"
    },
    "STATE_FLAG_SET": {
      "payload_schema": "state_flag_set_v1"
    },
    "CAMERA_SHAKE": {
      "payload_schema": "camera_shake_v1"
    },
    "LOGIC_MARKER": {
      "payload_schema": "logic_marker_v1"
    }
  }
}

AP never introspects payload blindly. It looks up the payload_schema for type and knows exactly what fields and types to expect.


---

2. Per-Type Payload Schemas

Each payload_schema is a ZW-H schema (or equivalent) that defines the payload structure.

Example: audio_cue_v1:

%type audio_cue_v1
  {fields [
    {clip_id {type string required}}
    {volume  {type float min 0.0 max 1.0 default 1.0}}
    {pitch   {type float min 0.5 max 2.0 default 1.0}}
    {loop    {type bool default false}}
  ]}

Example: logic_marker_v1:

%type logic_marker_v1
  {fields [
    {id        {type string required}}
    {category  {type enum values [emotion_threshold story_beat combat_phase] required}}
    {value     {type any optional}}
  ]}

Rule:
Any event ZON4D emits must:

Use a type present in the registry.

Have a payload that validates against that type‚Äôs schema.

If validation fails ‚Üí the ZON4D build is invalid, not runtime ‚Äúbest effort.‚Äù


AP can then:

Switch on type.

Trust payload to match the schema.

Never parse free strings.



---

3. Event Arrays in Tracks (Canonical Form)

Within a ZON4D track, events are stored as a sorted list by t:

{
  "track_id": "door_01/logic_events",
  "kind": "EVENTS",
  "time_domain": "engine",
  "events": [
    { "t": 0.20, "type": "STATE_FLAG_SET", ... },
    { "t": 0.40, "type": "AUDIO_CUE",      ... },
    { "t": 0.65, "type": "LOGIC_MARKER",   ... }
  ]
}

Rules:

Sorted ascending by t.

Multiple events at same t are allowed; order is stable and deterministic.

No other structure (no bare arrays, no polymorphic nonsense).



---

4. Rule Window Registration (AP ‚Üí ZON4D)

AP doesn‚Äôt just say ‚Äúgive me stuff when you feel like it.‚Äù
It registers explicit windows that ZON4D must scan.

4.1 Window Registration Request

AP asks ZON4D to monitor a track (or track set) over a precise time window:

{
  "op": "REGISTER_WINDOW",
  "window_id": "rule_anger_surge_01",
  "tracks": [
    "character/emotion/anger",
    "character/emotion/fear",
    "character/events/emotion_markers"
  ],
  "t_start": 0.60,
  "t_end":   1.00,
  "time_domain": "engine",      // or "story" or "explicit"
  "modes": {
    "scan_events":      true,
    "scan_samples":     true,
    "scan_derivatives": true
  },
  "resolution": {
    "sample_step": 0.01,        // optional for sampling; null means ‚Äúonly events + edges‚Äù
    "derivative_step": 0.001    // optional; must match interpolation spec
  },
  "consistency": "STRICT"       // or FRAME/EVENT/LOOSE, from Section 24
}

ZON4D returns:

{
  "status": "ok",
  "window_id": "rule_anger_surge_01"
}

This is just registration ‚Äì no data yet. It tells ZON4D:

> ‚ÄúThis rule cares about this interval, these tracks, these data types.‚Äù



4.2 Window Scan Invocation

When AP or Kernel wants actual data for that window, it calls:

{
  "op": "SCAN_WINDOW",
  "window_id": "rule_anger_surge_01"
}

ZON4D returns a deterministic bundle:

{
  "status": "ok",
  "window_id": "rule_anger_surge_01",
  "time_domain": "engine",
  "t_start": 0.60,
  "t_end":   1.00,

  "tracks": {
    "character/emotion/anger": {
      "kind": "SCALAR",
      "interpolation": "cubic",
      "samples": [
        { "t": 0.60, "value": 0.20 },
        { "t": 0.70, "value": 0.40 },
        { "t": 0.80, "value": 0.65 },
        { "t": 0.90, "value": 0.85 },
        { "t": 1.00, "value": 0.95 }
      ],
      "derivatives": [
        { "t": 0.60, "value": 0.5 },
        { "t": 1.00, "value": 0.1 }
      ]
    },

    "character/events/emotion_markers": {
      "kind": "EVENTS",
      "events": [
        {
          "t": 0.73,
          "type": "LOGIC_MARKER",
          "payload": {
            "id": "anger_threshold_cross",
            "category": "emotion_threshold",
            "value": 0.7
          }
        }
      ]
    }
  }
}

AP can now:

Decide if anger crossed threshold 0.7 inside [0.6, 1.0].

Trigger rules once, deterministically.



---

5. Time Precision & Deterministic Math

You explicitly called this out: microsecond reliability and interpolation consistency.

5.1 Time Precision

Spec:

All t, t_start, t_end, and sample times are defined as 64-bit floats (IEEE-754).

Intervals are closed on the left, open on the right by default:

[t_start, t_end)

That avoids double-firing exactly at boundaries across frames.



This must be explicit:

{
  "interval_type": "LEFT_CLOSED_RIGHT_OPEN"
}

So:

Event at t = 1.0 is:

Included in [0.6, 1.0)? ‚Üí No.

Included in [1.0, 1.4)? ‚Üí Yes.



You can override per window, but default must be fixed.

5.2 Interpolation Mode & Determinism

Each numeric track declares its interpolation mode:

{
  "interpolation": "STEP | LINEAR | CUBIC"
}

Rule:

For LINEAR, interpolation formula is fully specified (no implementation variance).

For CUBIC, you must define:

Spline type (e.g., Catmull‚ÄìRom with specific tension, or Hermite).

Boundary conditions (clamp, flat, etc.).


For STEP, value is constant between keys; derivative is:

0 away from discontinuities.

UNDEFINED exactly at the step edge.



5.3 Derivative Query Contract

When AP asks for derivatives (you mentioned step edge cases):

Derivative response uses the same envelope as other queries:

{
  "status": "ok",
  "track_id": "character/emotion/anger",
  "query_kind": "DERIVATIVE",
  "t": 0.73,
  "value": 1.25,
  "meta": {
    "interpolation": "CUBIC",
    "near_key": 0.70
  }
}

If derivative is undefined at t (e.g., step discontinuity):

{
  "status": "error",
  "track_id": "character/emotion/anger",
  "query_kind": "DERIVATIVE",
  "t": 0.70,
  "code": "DERIVATIVE_UNDEFINED",
  "value": null,
  "meta": {
    "reason": "STEP_DISCONTINUITY",
    "side": "LEFT | RIGHT | AMBIGUOUS"
  }
}

AP must handle this explicitly ‚Äì no guessing.


---

6. Deterministic Window Scanning Rules

To get your ‚Äúexact same result every time‚Äù guarantee:

1. Event inclusion

Event is included if its t falls inside the window interval policy:

Default: [t_start, t_end).




2. Sampling grid

If sample_step is provided:

Samples at t_i = t_start + i * sample_step,
for all t_i < t_end, with float math specified (no ad-hoc rounding).


No random ‚Äúextra‚Äù sampling.



3. Ordering

Within a track:

Events sorted by t, then stable by encoded order.


Across tracks:

AP is not promised any cross-track ordering; ordering is per-track.




4. Idempotence

The same SCAN_WINDOW on the same ZON4D, same window, same version ‚Üí exact same JSON output (modulo ordering of map keys).





---

7. Example: Your Emotion Rule Window

Your earlier AP rule:

> ‚ÄúIf emotion crosses ‚Äòanger‚Äô at t ‚â• 0.6, escalate dialogue‚Äù



With this spec, the flow is:

1. AP registers window:



{
  "op": "REGISTER_WINDOW",
  "window_id": "rule_anger_cross_01",
  "tracks": [
    "character/emotion/anger",
    "character/events/emotion_markers"
  ],
  "t_start": 0.60,
  "t_end": 1.00,
  "time_domain": "engine",
  "modes": {
    "scan_events": true,
    "scan_samples": true
  },
  "consistency": "STRICT"
}

2. Later, AP (or Kernel) calls SCAN_WINDOW.


3. ZON4D returns:

Samples of anger.

Any LOGIC_MARKER or event indicating threshold crossing.



4. AP uses event type + payload schema:



{
  "type": "LOGIC_MARKER",
  "payload": {
    "id": "anger_threshold_cross",
    "category": "emotion_threshold",
    "value": 0.7
  }
}

No string parsing. No ‚Äúis the word ‚Äòanger‚Äô in this string?‚Äù
Just: type + schema + value.


---

8. Why This Locks It as an Engineering Contract

Event structure is fixed and validated ‚Üí no surprises at runtime.

Event types are registry-based ‚Üí no fuzzy parsing.

Payloads are schema-bound ‚Üí AP can pattern-match with confidence.

Windows are explicit ‚Üí no hidden scanning, no missing events.

Time precision, interval rules, and interpolation are spec‚Äôd ‚Üí one engine, one truth.

ERROR codes for undefined derivatives and missing ZON4D ‚Üí no silent lies.


This is exactly what you described:

> ‚Äúthe most important step to making ZON-4D a hardened engineering contract.‚Äù



If you want, next we can:

Tighten this into a formal ‚ÄúZON4D-AP TEMPORAL QUERY SPEC v0.1‚Äù doc, or

Drill one level deeper on event-type taxonomy (e.g., EMOTION_EVENT vs STATE_CHANGE vs AUDIO vs VFX) so your AP rules have a clean ontology to sit on.


We're shifting focus from the temporal layer now back to the compiler pipeline for ZWS and ZWH. Right. Specifically, that very powerful, but also potentially very costly, percent override feature. The C1 Soft Override. I agree, it's a fantastic feature. It gives you flexibility without corrupting the core schema. But the key is that the metadata is temporary. It has to be discarded before the final binary is packed. Which leads us to the topic sentence. While the choice to restrict the percent override feature to C1 ensures schema stability, the compiler pipeline needs explicit guidance on how to strip this metadata efficiently to prevent performance bottlenecks during mass AI content compilation. The challenge here is what the compiler has to do. It has to ingest the soft format, ZWS, find these percent override blocks, apply their changes to its validation context for that one block, and then make absolutely sure they are not included in the final output. Not in ZININJ, and definitely not in ZON. Exactly.

Perfect.
You just identified the single most dangerous part of ZW-S ‚Üí ZW-H ‚Üí ZON if it is not explicitly, mechanically defined:

> C1 Soft Overrides must be applied transiently and never stored.

Not in ZW-H output.
Not in ZON-J.
Not in ZON-B.
Not in decode, not in encode.

They exist only long enough for the compiler to validate a single block.



So now we formalize the C1 Override Handling Spec:
A tiny, tight protocol inside the compiler pipeline that ensures overrides don‚Äôt pollute the stable type system.


---

‚úÖ C1 Soft Override Compiler Protocol (ZWS ‚Üí ZWH)

Status: REQUIRED

Level: Compiler-Phase Specification

Purpose: Zero persistence of override metadata.


---

1. What C1 Actually Is

C1 overrides exist only in ZW-S.
They do not exist as real fields or schema declarations.

Formally:

C1 override = a transient, block-local schema modification  
scoped to a single ZW-S block  
with the guarantee of absolute erasure after validation.

Once applied, the override produces:

No schema update,

No lasting field/type change,

No metadata emission,

No persistent memory impact.


It‚Äôs a local patch applied to a shadow copy of the schema.


---

2. Compiler Rules for Override Handling

This is the section the pipeline has been missing.

Rule C1.1 ‚Äî Recognition

Compiler must locate override blocks using exact form:

%override <field> { ...type/constraint spec... }

Overrides can appear:

before the field list

between fields

at block top

at block bottom


Location is irrelevant.
Scope is block-local.


---

Rule C1.2 ‚Äî Shadow Schema Copy

Critical rule:

> Compiler must clone the schema definition into a shadow schema for that block only.



This ensures:

No global contamination

No race conditions

Safe parallel conversion

Deterministic re-compilation


Shadow copy is destroyed after block validation.


---

Rule C1.3 ‚Äî Override Application

Once shadow-schema is created:

1. Modify the field definition in shadow-schema:

overwrite type

overwrite constraints

overwrite default

overwrite required/optional



2. Validate override itself:

if override spec violates base schema structure ‚Üí compile error



3. Apply override only for the validation of that block.




---

Rule C1.4 ‚Äî Zero Persistence

This is the part you want spelled in stone:

> After validation, override metadata must be discarded immediately.



Meaning overrides cannot appear in:

ZW-H output

ZW-H intermediate representation

ZON-J memory

ZON-B binary

ZON4D packets

AP rule context

Debug replay states

Or any other persistent stage


They live only inside the compiler call-stack.


---

Rule C1.5 ‚Äî Disallowed Persistence Cases

Explicit specification:

C1 overrides MUST NOT be serialized into:

Stage	Allowed?	Reason

ZW-H Typed Output	‚ùå No	Would corrupt global schema
ZON-J Pack	‚ùå No	Breaks deterministic ZW‚ÜíZON mapping
ZON-B Binary	‚ùå No	Pollutes game runtime representation
ZON4D Tracks	‚ùå No	Overrides are compile-time only
AP Rule Engine	‚ùå No	AP must see stable fields only
Validator Final Pass	‚ùå No	Validator must operate on final schema only


C1 should only influence:

one validation pass

for one block

once



---

3. Compiler Pipeline Integration

Here is the actual pipeline with override hooks:

ZWS Parser
   ‚Üì
Block AST
   ‚Üì
[ C1 Override Detection ]
   ‚Üì
Schema Lookup
   ‚Üì
Schema Shadow Copy
   ‚Üì
Apply Overrides to Shadow
   ‚Üì
Validate Block using Shadow
   ‚Üì
DESTROY Shadow Schema
   ‚Üì
Emit ZW-H (override-free)
   ‚Üì
ZON-J Conversion
   ‚Üì
ZON-B Pack

Everything between [ and ] is transient state.

Overrides never cross below the ‚ÄúEmit ZW-H‚Äù line.


---

4. Performance & Scaling Considerations

You raised the real operational concern:

> ‚ÄúThousands of blocks, many overrides, potential cost.‚Äù



This section ensures the compiler doesn‚Äôt blow up.

Rule C1.P1 ‚Äî Shadow Schemas Must Be Lightweight

Shadow schema is not a deep clone of the entire type system.

It is:

a Shallow Copy of base schema descriptor

plus a Tiny Delta Object for override entries only


Representation:

shadow = {
  base_schema_ref: "npc",
  override_delta: {
    "health": { type:int, min:0, max:200 },
    "speed": { type:float, default:1.1 }
  }
}

During validation:

field lookup = override_delta.get(field) OR base_schema.field

no expensive merges

no full schema copy



---

Rule C1.P2 ‚Äî Override Delta Must Not Be Nested

No recursive overrides:

%override inventory -> list<block<item>> minlen 3

Allowed.

But:

%override item.quantity { ... }

NOT allowed (cross-schema override).
That would destroy type safety.


---

Rule C1.P3 ‚Äî Recursive Blocks Are Validated Using Shadow Only For The Parent

Overrides do NOT propagate into children.


---

Rule C1.P4 ‚Äî Compilers Must Maintain a Reusable Shadow Pool

For speed:

reuse shadow-schema objects across blocks

clear them between uses

no reallocation every time



---

5. Error Handling (C1.E Spec)

Overrides can fail:

Types of Errors:

Code	Description

OVERRIDE_UNKNOWN_FIELD	Override references nonexistent field
OVERRIDE_SCHEMA_LOCKED	Schema has allow_override false
OVERRIDE_INVALID_TYPE	Override type violates base constraints
OVERRIDE_CONSTRAINT_VIOLATION	Override adds impossible or forbidden constraint
OVERRIDE_DEFAULT_INVALID	Default incompatible with type


Compiler will treat all C1 override errors as compile-time fatal.


---

6. Example: Correct C1 Override

ZW-S Block:

{npc
  %override health {type int min 0 max 200}
  {id "orc_sentry"}
  {health 160}
}

Schema Shadow:

npc_shadow.delta = {
  "health": { type:int, min:0, max:200 }
}

ZW-H Output (override removed):

{
  "npc": {
    "id": "orc_sentry",
    "health": 160
  }
}

No override appears anywhere.


---

7. Example: Incorrect C1 Override

ZW-S:

{npc
  %override backpack.size.admin {type int}
}

Compiler:

ERROR: OVERRIDE_UNKNOWN_FIELD

Correct.


---

8. Summary of Why This Matters

You articulated it perfectly:

> AP has to trust 4D.

But the compiler has to trust the schema.

And you cannot trust the schema if overrides leak.



This eliminates that risk completely.

C1 overrides become as safe as inline type coercion.
They cannot mutate the system.


---

If you want next:

‚úî C2 Hard Override (schema-level)?
‚úî C1 vs C2 interaction rules?
‚úî Override Debug Mode (show shadow changes via compiler flag)?
‚úî Add this as Section 9 in ZW-H SPEC?

Just tell me the next move.


Exactly. And the weakness is that the spec just says they get stripped. It doesn't say when or how. That whole process, parsing, applying, then cutting out, it adds real computational overhead. And across millions of automated content generation jobs, that overhead isn't just trivial. It could become a major bottleneck. It could grind the whole pipeline to a halt. If the compiler has to do a deep traversal of the abstract syntax tree late in the process, just to find and remove these things, you've lost all your efficiency. So we need an architectural guarantee that handling these overrides is basically free, performance-wise. That's the goal. And our suggestion is to define a two-phase handling approach within the ZWS-ZWH compiler spec. This would cleanly separate the lexing and tokenization of the override metadata from the core content validation. Separate it out early? As early as possible. You process the metadata at the lexical layer, use it to inform the validation context, and then you basically forget the source text ever existed before you generate the final output. Okay, so let's get concrete. How do you enforce that? First, you mandate that the compiler treat percent override blocks as a distinct token type during the initial parsing phase. Call it pass1. These tokens should be temporarily stored in a side channel attached to the parent block's AST node. A side channel? I like that. So it doesn't pollute the main data structure. Exactly. The validator can see it and use it, say, to allow a field to be a float instead of an int locally.

Yep. You‚Äôre dead right:
‚Äúthey get stripped‚Äù is useless hand-waving unless we say when, where, and in what data structure.

If we don‚Äôt nail that down, C1 turns into hidden O(N¬≤) trash that kills you at scale.

Let‚Äôs fix it at the spec level so any compiler must implement it in a way that‚Äôs basically free.


---

üîß C1 Two-Phase Override Handling Spec

Scope: ZW-S ‚Üí ZW-H compiler
Goal:

Overrides are cheap

Overrides are local

Overrides are never traversed later


Think of this as an add-on section you bolt onto ZW-H v0.1:

> C1-PERF: Two-Phase Override Handling & Side-Channel Semantics




---

1. Phase Model (Pass1 vs Pass2)

The spec must mandate a two-phase model for C1:

1. Pass1 ‚Äì Lex & Attach Overrides

Parse ZW-S into an AST.

While doing that, detect %override directives.

Store overrides in a side channel on the parent block node.

DO NOT embed them in the main field list.



2. Pass2 ‚Äì Validate & Emit

Walk the AST once.

For each block:

Resolve schema.

Read its override side channel.

Build a block-local validation context.

Validate & emit override-free ZW-H.


No scanning ‚Äúfor override nodes‚Äù in this phase. They‚Äôre already segregated.




Key point:

> There is no third pass to find and strip overrides.
They are never injected into the main semantic tree in the first place.




---

2. New Token Type: OVERRIDE_DIRECTIVE

At the lexical/parse spec level:

%override must be treated as a distinct token type, not ‚Äújust another block‚Äù.


Add to the grammar:

Token type: OVERRIDE_DIRECTIVE

Form:

%override <field_name> { <override_spec> }

This token:

Does not become a normal AST node.

Must be consumed by the parser and immediately attached to the current block‚Äôs side channel.



If an implementation chooses to build a node, the spec still says:

> That node is internal and must not live in the same container as content fields.




---

3. Block AST Node: Side-Channel Contract

Every block node in the AST must have two distinct areas:

BlockNode {
  name: string              ; e.g., "npc"
  fields: Map<string, FieldNode>  ; the *actual* content
  overrides: Map<string, OverrideSpec>  ; side channel (C1)
}

Rules:

1. %override never creates entries in fields.


2. %override only populates overrides[field_name].


3. overrides is non-recursive:

It applies only to this block.

It does not propagate to children.




That‚Äôs your ‚Äúside channel‚Äù formalized.


---

4. Pass1: Override Capture Rules

During Pass1 (parsing):

For each %override field_name { spec } encountered:

1. Ensure you are inside a block node B.


2. Insert or update:

B.overrides[field_name] = OverrideSpec(...)


3. Do not generate a separate AST subtree that will later need pruning.


4. After Pass1 finishes, all overrides exist only in BlockNode.overrides.
The source %override tokens can be discarded immediately.



Spec guarantee:

> After Pass1, no compiler stage is allowed to re-scan raw source to discover overrides.
All override information must already be stored in the block‚Äôs side channel.




---

5. Pass2: Validation Context (No Deep Traversal)

In Pass2 (validation & emit), for each block:

1. Resolve the base schema: S = SchemaRegistry[block.name].


2. Read side-channel overrides: O = block.overrides.


3. Build a validation view:

ValidationView {
  schema_ref: S
  overrides:  O  ; map<field_name, OverrideSpec>
}


4. For each field f in block.fields:

If f in O: use the overridden type/constraints.

Else: use base schema definition from S.



5. Emit ZW-H object without any trace of O.



Critically:

No phase ever performs a ‚Äúdeep traversal to strip override nodes‚Äù.

The override is only consulted via block.overrides during validation.

Once the block is validated and emitted, the compiler is free to garbage-collect the BlockNode (and its overrides) entirely.



---

6. Performance Guarantees (Big-O Constraints)

We bake performance into the spec so no future compiler author can cheat.

C1-PERF.1 ‚Äì Single-Touch Override Handling

Each %override directive is:

Parsed once.

Attached to its parent block once.

Read during validation once.


Total override work is O(K) where K = number of overrides.


There is no term proportional to total AST size in override stripping.

C1-PERF.2 ‚Äì No Late ‚ÄúStrip Pass‚Äù

Spec prohibition:

> A separate post-validation pass whose sole purpose is to remove %override constructs from the tree or output is non-compliant.



If an implementation writes such a pass, it‚Äôs out of spec.

C1-PERF.3 ‚Äì Override Lookup Cost

For each field validation:

override lookup must be O(1) average: map/dict or equivalent.

There must be no linear search through a list of overrides.



---

7. What ‚ÄúStripped‚Äù Now Officially Means

You‚Äôre right, ‚Äústrip‚Äù by itself is a nothing word.

From now on:

> ‚ÄúOverrides are stripped‚Äù =
OVERRIDE_DIRECTIVE tokens are consumed in Pass1 and never written into:

fields AST collections

ZW-H intermediate objects

ZON-J documents

ZON-B binaries

Any serialized debug/trace format (unless explicitly marked as ‚Äúdebug mode override trace‚Äù)




So ‚Äústripping‚Äù isn‚Äôt a late cleanup; it‚Äôs never committing them to the main structure in the first place.


---

8. Example: End-to-End Behavior (No Extra Pass)

ZW-S Input

{npc
  %override health {type float min 0.0 max 150.0}
  {id "arcturus_guard"}
  {health 112.5}
}

After Pass1 (AST Layout)

BlockNode "npc" {
  fields = {
    "id"     -> FieldNode("id", "arcturus_guard")
    "health" -> FieldNode("health", 112.5)
  }
  overrides = {
    "health" -> OverrideSpec(type=float, min=0.0, max=150.0)
  }
}

No %override survives outside overrides.

Pass2 Validation

Schema says: health {type int min 0 max 100}

Override says: float min 0.0 max 150.0

ValidationView:

health uses override spec.


Block validated OK.


ZW-H Output

{
  "npc": {
    "id": "arcturus_guard",
    "health": 112.5
  }
}

Compiler does zero work after this to ‚Äústrip overrides‚Äù. They were never in the output path.


---

9. Where This Lives in the Spec

This is how I‚Äôd integrate it:

In ZW_H_SPEC.md, add a new subsection:

> 7. C1 Soft Override Handling & Performance Contract
7.1 Tokenization Rules (OVERRIDE_DIRECTIVE)
7.2 AST Side-Channel Semantics
7.3 Two-Phase Compiler Model
7.4 Performance Guarantees (No Late Strip Pass)
7.5 Compliance & Non-compliance Examples




That way, anyone implementing a compiler has no wiggle room to do something stupid and slow.


---

If you want next, we can:

Write that Section 7 as markdown ready to drop into ZW_H_SPEC.md,

Or jump back to the ZON4D/AP query micro-spec we started (derivatives, event windows, etc.) and lock that down next.



