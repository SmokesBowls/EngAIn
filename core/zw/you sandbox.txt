Nice! Here’s a complete, drop-in ZWSandbox.gd that finishes your simulator: it lists all ZWEvents signals, lets you fire them with ad-hoc params, tweak flags and inventory, and gracefully degrades if a singleton is missing. It also parses JSON in the param boxes so you can pass dicts/arrays cleanly.

extends Control
class_name ZWSandbox

@onready var event_selector: OptionButton = $VBox/EventSimulator/EventSelector
@onready var param_inputs: Array[LineEdit] = [
    $VBox/EventSimulator/Param1,
    $VBox/EventSimulator/Param2,
    $VBox/EventSimulator/Param3
]
@onready var fire_event_btn: Button = $VBox/EventSimulator/FireEventBtn
@onready var event_feedback: Label = $VBox/EventSimulator/Feedback

@onready var flag_input: LineEdit = $VBox/StateTweaker/FlagName
@onready var flag_value: LineEdit = $VBox/StateTweaker/FlagValue
@onready var set_flag_btn: Button = $VBox/StateTweaker/SetFlagBtn
@onready var flag_feedback: Label = $VBox/StateTweaker/Feedback

@onready var inventory_input: LineEdit = $VBox/StateTweaker/ItemId
@onready var inventory_qty: SpinBox = $VBox/StateTweaker/Quantity
@onready var give_item_btn: Button = $VBox/StateTweaker/GiveItemBtn
@onready var inv_feedback: Label = $VBox/StateTweaker/InventoryFeedback

var runtime: Node = null
var events: Node = null
var flags: Node = null
var inventory: Node = null

func _ready() -> void:
    runtime = _find_singleton("ZWRuntime")
    events = _find_singleton("ZWEvents")
    flags = _find_singleton("ZWFlags")
    inventory = _find_singleton("ZWInventory")

    _populate_event_selector()

    fire_event_btn.pressed.connect(_on_fire_event)
    set_flag_btn.pressed.connect(_on_set_flag)
    give_item_btn.pressed.connect(_on_give_item)

    # Optional: live log from ZWEvents if it keeps a ring buffer
    if events and events.has_method("get_event_log"):
        events.add_post_middleware(Callable(self, "_post_emit_tap"))

func _find_singleton(name: String) -> Node:
    if has_node("/root/" + name):
        return get_node("/root/" + name)
    if Engine.has_singleton(name):
        return Engine.get_singleton(name)
    return null

func _populate_event_selector() -> void:
    event_selector.clear()
    if not events:
        event_selector.add_item("No ZWEvents found")
        return
    var signals: Array = events.get_signal_list()
    signals.sort_custom(func(a,b): return String(a.name) < String(b.name))
    for sig in signals:
        event_selector.add_item(sig.name)

func _on_fire_event() -> void:
    if not events:
        _set_text(event_feedback, "ZWEvents not found (autoload?)")
        return

    var sig_name := event_selector.get_item_text(event_selector.get_selected_id())
    if not events.has_signal(sig_name):
        _set_text(event_feedback, "Signal not found: %s" % sig_name)
        return

    # Try typed emit helpers first (nice UX), fall back to generic emit_signal.
    var args: Array = []
    for inp in param_inputs:
        var raw := inp.text.strip_edges()
        if raw == "": continue
        args.append(_parse_value(raw))

    var emitted := false
    var helper_name := _helper_for_signal(sig_name)
    if helper_name != "" and events.has_method(helper_name):
        # Pad/trim to helper’s expected arity if necessary (we’ll just forward as-is)
        events.callv(helper_name, args)
        emitted = true
    else:
        # Fire raw signal (must match connected signatures)
        events.emit_signal(sig_name, args.size() > 0 ? args[0] : null,
                                     args.size() > 1 ? args[1] : null,
                                     args.size() > 2 ? args[2] : null)
        emitted = true

    if emitted:
        _set_text(event_feedback, "Emitted: %s(%s)" % [sig_name, _preview_args(args)])
    else:
        _set_text(event_feedback, "Failed to emit: %s" % sig_name)

func _on_set_flag() -> void:
    var name := flag_input.text.strip_edges()
    if name == "":
        _set_text(flag_feedback, "Flag name required")
        return
    var val_text := flag_value.text.strip_edges()
    var value := _parse_value(val_text)

    if flags and flags.has_method("set_flag"):
        flags.set_flag(name, value)
        if events and events.has_signal("zw_flag_changed"):
            events.emit_signal("zw_flag_changed", name, value)
        _set_text(flag_feedback, "Flag set: %s = %s" % [name, str(value)])
    else:
        _set_text(flag_feedback, "ZWFlags not found or missing set_flag(name,value)")

func _on_give_item() -> void:
    var item_id := inventory_input.text.strip_edges()
    var qty := int(inventory_qty.value)
    if item_id == "" or qty <= 0:
        _set_text(inv_feedback, "Item id and positive quantity required")
        return

    if inventory and inventory.has_method("add_item"):
        inventory.add_item(item_id, qty)
        if events:
            if events.has_method("emit_item_obtained"):
                events.emit_item_obtained(item_id, qty, "Sandbox", null)
            elif events.has_signal("zw_item_obtained"):
                events.emit_signal("zw_item_obtained", item_id, qty, "Sandbox", null)
        _set_text(inv_feedback, "Gave %dx %s" % [qty, item_id])
    else:
        _set_text(inv_feedback, "ZWInventory not found or missing add_item(id,qty)")

# -------- Helpers --------

func _parse_value(text: String) -> Variant:
    # Try JSON first (Dictionary/Array/numbers/booleans/null)
    # Accept single quotes by swapping to double quotes for quick tests.
    var try_text := text
    if try_text.find("'") != -1 and try_text.find("\"") == -1:
        try_text = try_text.replace("'", "\"")
    var json := JSON.new()
    var ok := json.parse(try_text)
    if ok == OK:
        return json.data

    # Fallbacks: bools, ints, floats, time-like strings pass through
    match text.to_lower():
        "true":
            return true
        "false":
            return false
        "null":
            return null
    if text.is_valid_int():
        return int(text)
    if text.is_valid_float():
        return float(text)
    return text  # plain string

func _preview_args(args: Array) -> String:
    var parts := []
    for a in args:
        parts.append(typeof(a) in [TYPE_DICTIONARY, TYPE_ARRAY] ? to_json(a) : str(a))
    return ", ".join(parts)

func _helper_for_signal(sig_name: String) -> String:
    # Map known signals → nice helper methods from ZWEvents
    var map := {
        "zw_action": "emit_action",
        "zw_block_activated": "emit_block_activated",
        "zw_block_deactivated": "emit_block_deactivated",
        "zw_block_interacted": "emit_block_interacted",
        "zw_dialogue_started": "emit_dialogue_started",
        "zw_dialogue_ended": "emit_dialogue_ended",
        "zw_quest_started": "emit_quest_started",
        "zw_quest_completed": "emit_quest_completed",
        "zw_quest_step_completed": "emit_quest_step_completed",
        "zw_location_entered": "emit_location_entered",
        "zw_location_exited": "emit_location_exited",
        "zw_area_discovered": "emit_area_discovered",
        "zw_item_obtained": "emit_item_obtained",
        "zw_item_consumed": "emit_item_consumed",
        "zw_item_equipped": "emit_item_equipped",
        "zw_item_unequipped": "emit_item_unequipped",
        "zw_reputation_changed": "emit_reputation_changed",
        "zw_character_met": "emit_character_met",
        "zw_character_mood_changed": "emit_character_mood_changed",
        "zw_time_advanced": "emit_time_advanced",
        "zw_day_changed": "emit_day_changed",
        "zw_weather_changed": "emit_weather_changed",
        "zw_custom": "emit_custom"
    }
    return map.get(sig_name, "")

func _post_emit_tap(signal_name: String, args: Array) -> void:
    # Passive tail tap to confirm dispatch into the UI label
    _set_text(event_feedback, "Emitted: %s(%s)" % [signal_name, _preview_args(args)])

func _set_text(lbl: Label, msg: String) -> void:
    if lbl:
        lbl.text = msg

Quick usage notes

Params parsing: Put JSON in Param boxes for complex payloads:
{"action":"open_door","target":"House.FrontDoor"}
or simple strings/numbers/bools (true, 42, 3.14).

Helper mapping: If a typed emit_* exists in ZWEvents, this uses it; otherwise it falls back to emitting the raw signal.

Flags/Inventory: Expects ZWFlags.set_flag(name,value) and ZWInventory.add_item(id,qty). If you named them differently, tell me the signatures and I’ll adapt.

Live log: If your ZWEvents has add_post_middleware + get_event_log, the sandbox label reflects last emission automatically.


Want a companion ZWInspector panel to list all current flags, inventory, active ZW blocks at the current location, and click-to-emit common events? I can wire that next.

